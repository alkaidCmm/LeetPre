
树中两个结点的最低公共祖先

题目：求树中两个结点的最低公共祖先，此树不是二叉树，并且没有指向父节点的指针。
题目解析

假设还是输入结点 F 和 H。
			A
		  B     C
       D/   \E
     F/ \G H/ I| G\
我们首先得到一条从根结点到树中某一结点的路径，这就要求在遍历的时候，有一个辅助内存来保存路径。比如我们用前序遍历的方法来得到从根结点到 H
的路径的过程是这样的：（ 1 ）遍历到 A，把 A 存放到路径中去，路径中只有一个结点 A；( 2 ）遍历到 B，把 B
存到路径中去，此时路径为 A->B; ( 3 ）遍历到 D，把 D 存放到路径中去，此，时路径为 A->B->D；( 4 ）：遍历到 F，把 F
存放到路径中去，此时路径为 A->B->D->F；( 5) F 已经没有子结点了，因此这条路径不可能到这结点 H。 把 F 从路径中删除，变成
A->B->D; ( 6 ）遍历 G。 和结点F 一样，这条路径也不能到达 H。边历完 G 之后，路径仍然是 A->B->D； ( 7 ）由于
D 的所有子结点都遍历过了，不可能到这结点 H，因此 D 不在从 A 到 H 的路径中，把 D 从路径中删除，变成 A->B； ( 8 ）遥历
E，把 E 加入到路径中，此时路径变成 A->B->E， ( 9 ）遍历 H，已经到达目标给点， A->B->E 就是从根结点开始到达 H
必须经过的路径。

同样，我们也可以得到从根结点开始到达 F 必须经过的路径是 A->B。接着，我们求出这两个路径的最后公共结点，也就是 B。B
这个结点也是 F 和 H 的最低公共祖先．

为了得到从根结点开始到输入的两个结点的两条路径，需要追历两次树，每边历一次的时间复杂度是
O(n）。得到的两条路径的长度在最差情况时是 0（通常情况丁两条路径的长度是 O(logn)。

注意：可以在只遍历树一次就找到两个结点的路径，这部分留给读者自己去完成。
同样，我们也可以得到从根结点开始到达 F 必须经过的路径是
A->B。接着，我们求出这两个路径的最后公共结点，也就是 B。B
这个结点也是 F 和 H 的最低公共祖先．

为了得到从根结点开始到输入的两个结点的两条路径，需要追历两次树，每边历一次的时间复杂度是
O(n）。得到的两条路径的长度在最差情况时是
0（通常情况丁两条路径的长度是 O(logn)。

注意：可以在只遍历树一次就找到两个结点的路径，这部分留给读者自己去完成。